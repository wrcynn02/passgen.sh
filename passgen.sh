#!/usr/bin/bash
#
# This is a rather minimal example Argbash potential
# Example taken from http://argbash.readthedocs.io/en/stable/example.html
#
# ARG_OPTIONAL_BOOLEAN([truly-random],[t],[Use /dev/random instead of /dev/urandom])
# ARG_OPTIONAL_SINGLE([mask],[m],[Password mask. Use keywords below for create mask:
# ARG_OPTIONAL_SINGLE([uppercase-count],[u],[Uppercase letters quantity],[0])
# ARG_OPTIONAL_SINGLE([lowercase-count],[l],[Lowercase letters quantity],[0])
# ARG_OPTIONAL_SINGLE([numbers-count],[n],[Digits quantity],[0])
# ARG_OPTIONAL_SINGLE([symbols-count],[s],[Special symbols quantity],[0])
# ARG_OPTIONAL_SINGLE([password-length],[p],[Password length],[0])
# ARG_TYPE_GROUP([int],[type string],[uppercase-count lowercase-count numbers-count symbols-count password-length])
# ARG_HELP([This is program which create secure and strong passwords],[Pay attention! You can't set quantity of numbers, symbols etc. when mask using or when you already set password length.])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.11.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.dev for more info
# Generated online by https://argbash.dev/generate


die()
{
	local _ret="${2:-1}"
	test "${_PRINT_HELP:-no}" = yes && print_help >&2
	echo "$1" >&2
	exit "${_ret}"
}

# validators

int()
{
	printf "%s" "$1" | grep -q '^\s*[+-]\?[0-9]\+\s*$' || die "The value of argument '$2' is '$1', which is not an integer."
	printf "%d" "$1"
}


begins_with_short_option()
{
	local first_option all_short_options='tmulnsph'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_truly_random="off"
_arg_mask=
_arg_uppercase_count="0"
_arg_lowercase_count="0"
_arg_numbers_count="0"
_arg_symbols_count="0"
_arg_password_length="0"


print_help()
{
	printf '%s\n' "This is program which create secure and strong passwords"
	printf 'Usage: %s [-t|--(no-)truly-random] [-m|--mask <arg>] [-u|--uppercase-count <arg>] [-l|--lowercase-count <arg>] [-n|--numbers-count <arg>] [-s|--symbols-count <arg>] [-p|--password-length <arg>] [-h|--help]\n' "$0"
	printf '\t%s\n' "-t, --truly-random: Use /dev/random instead of /dev/urandom (off by default)"
	printf '\t%s\n' "-m, --mask: Password mask. Use keywords below for create mask:
		[upcs] - uppercase letter
		[lowcs] - lowercase letter
		[num] - digit
		[chr] - random special symbol (like # $ * etc.)
	Example:
		./passgen.sh --mask \"[num] [upcs] [chr][lowcs]\"
"
	printf '\t%s\n' "-u, --uppercase-count: Uppercase letters quantity (default: 0)"
	printf '\t%s\n' "-l, --lowercase-count: Lowercase letters quantity (default: 0)"
	printf '\t%s\n' "-n, --numbers-count: Digits quantity (default: 0)"
	printf '\t%s\n' "-s, --symbols-count: Special symbols quantity (default: 0)"
	printf '\t%s\n' "-p, --password-length: Password length (default: 0)"
	printf '\t%s\n' "-h, --help: Prints help"
	printf '\n%s\n' "Pay attention! You can't set quantity of numbers, symbols etc. when mask using or when you already set password length."
}


parse_commandline()
{
	local _key
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			-t|--no-truly-random|--truly-random)
				_arg_truly_random="on"
				test "${1:0:5}" = "--no-" && _arg_truly_random="off"
				;;
			-t*)
				_arg_truly_random="on"
				_next="${_key##-t}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-t" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-m|--mask)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_mask="$2"
				shift
				;;
			--mask=*)
				_arg_mask="${_key##--mask=}"
				;;
			-m*)
				_arg_mask="${_key##-m}"
				;;
			-u|--uppercase-count)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_uppercase_count="$2"
				shift
				;;
			--uppercase-count=*)
				_arg_uppercase_count="${_key##--uppercase-count=}"
				;;
			-u*)
				_arg_uppercase_count="${_key##-u}"
				;;
			-l|--lowercase-count)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_lowercase_count="$2"
				shift
				;;
			--lowercase-count=*)
				_arg_lowercase_count="${_key##--lowercase-count=}"
				;;
			-l*)
				_arg_lowercase_count="${_key##-l}"
				;;
			-n|--numbers-count)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_numbers_count="$2"
				shift
				;;
			--numbers-count=*)
				_arg_numbers_count="${_key##--numbers-count=}"
				;;
			-n*)
				_arg_numbers_count="${_key##-n}"
				;;
			-s|--symbols-count)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_symbols_count="$2"
				shift
				;;
			--symbols-count=*)
				_arg_symbols_count="${_key##--symbols-count=}"
				;;
			-s*)
				_arg_symbols_count="${_key##-s}"
				;;
			-p|--password-length)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_password_length="$2"
				shift
				;;
			--password-length=*)
				_arg_password_length="${_key##--password-length=}"
				;;
			-p*)
				_arg_password_length="${_key##-p}"
				;;
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			*)
				_PRINT_HELP=yes die "FATAL ERROR: Got an unexpected argument '$1'" 1
				;;
		esac
		shift
	done
}

parse_commandline "$@"

# OTHER STUFF GENERATED BY Argbash
# Validation of values

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash


upper=("A" "B" "C" "D" "E" "F" "G" "H" "I" "J" "K" "L" "M" "N" "O" "P" "Q" "R" "S" "T" "U" "V" "W" "X" "Y" "Z")
lower=("a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s" "t" "u" "v" "w" "x" "y" "z")
numbers=("0" "1" "2" "3" "4" "5" "6" "7" "8" "9")
symbols=("!" "@" "#" "$" "%" "^" "&" "asterisk" "(" ")" "-" "_" "=" "+" "|" "?" "~" '`' "'" "," "." "<" ">" ":" ";")
change=()

export DEV_RANDOM=/dev/urandom
if [[ "$_arg_truly_random" == "on" ]]; then
  export DEV_RANDOM=/dev/random
fi


function random_item() {
  array=("$@")
  if (( ${#array[@]} == 0 )); then
  	return -1
  elif (( ${#array[@]} == 1 )); then
  	echo ${array[0]}
  else
  	random_byte=$(dd if=$DEV_RANDOM bs=1 count=1 2>/dev/null | od -An -tu1)
  	index=$((random_byte % ${#array[@]}))
  	echo ${array[$index]}
  fi
}


function replace_expression() {
  array=("$@")
  array=("${array[@]:2}")
  string=$1
  expression=$2

  while [[ "$string" == *"$expression"* ]]; do
    repl=$(random_item ${array[@]})
    if [[ "$repl" == "asterisk" ]]; then
    	repl=\*
    fi

    exp2="${expression:1:$((${#expression}-2))}"
    string=$(echo "$string" | sed "s/\[$exp2\]/$repl/")
  done
  echo $string
}


function pass_by_mask() {
  mask=$1
  result=$(replace_expression "$mask" "[upcs]" ${upper[@]})
  result=$(replace_expression "$result" "[lowcs]" ${lower[@]})
  result=$(replace_expression "$result" "[num]" ${numbers[@]})
  result=$(replace_expression "$result" "[chr]" ${symbols[@]})
  echo "$result"
}


function remove_item() {
  array=("$@")
  array=("${array[@]:1}")
  item=$1
  result=()
  for array_item in ${array[@]}; do
    if [[ "$item" != "$array_item" ]]; then
      result+=("$array_item")
    fi
  done
  echo ${result[@]}
}


if [[ "$_arg_mask" != "" ]]; then
  pass_by_mask "$_arg_mask"
  exit 0
fi

length=$_arg_password_length
c1=$_arg_uppercase_count
c2=$_arg_lowercase_count
c3=$_arg_numbers_count
c4=$_arg_symbols_count

quantity_setting=false
if (( length <= 0 )); then
  length=$(( c1 + c2 + c3 + c4 ))
  if (( length <= 0 )); then
    exit 0
  else
  	change=()
  	if (( c1 > 0 )); then
  		change+=("[upcs]")
  	fi

  	if (( c2 > 0 )); then
  		change+=("[lowcs]")
  	fi

  	if (( c3 > 0 )); then
			change+=("[num]")
  	fi

  	if (( c4 > 0 )); then
			change+=("[chr]")
  	fi
  
    quantity_setting=true
  fi
else
	change=("[upcs]" "[lowcs] [num] [chr]")
fi


# Generate a mask
mask=""
for (( i=0; i<$length; i++ )); do
  target="$(random_item ${change[@]})"
  mask+="$target"

  if $quantity_setting; then
    delete=false
    case $target in
      "[upcs]" )
        ((c1--))
        if ((c1 <= 0)); then
          change=("$(remove_item $target ${change[@]})")
        fi
      ;;
      "[lowcs]" )
        ((c2--))
        if ((c2 <= 0)); then
          change=("$(remove_item $target ${change[@]})")
        fi
      ;;
      "[num]" )
        ((c3--))
        if ((c3 <= 0)); then
          change=("$(remove_item $target ${change[@]})")
        fi
      ;;
      "[chr]" )
        ((c4--))
        if ((c4 <= 0)); then
          change=("$(remove_item $target ${change[@]})")
        fi
      ;;
    esac
  fi
done

pass_by_mask $mask

# ] <-- needed because of Argbash
